### 操作系统原理 11

#### 进程通信

##### 管道通信

**仅能在父子与兄弟进程间通信**
$e.g:$
(父)进程A $\Rightarrow$ Pipe $\Rightarrow$ 进程B(子)


##### 响应比高者优先调度算法

$响应比 = 1 + \frac{等待时间}{运行时间}$

调度作业时计算作业列表中每个作业的响应比，选择响应比最高的作业优先投入运行。

如果作业等待时间相同，则运行时间越短的作业，其响应比越高，因此越容易被调度。因而有利于短作业。

如果作业运行时间相同，则等待时间越长的作业，其响应比越高，因此越容易被调度。因而有利于等候时间很长的作业。

对于运行时间长的作业，其优先级可以随等待时间的增加而提高，当其等待足够久的时侯，也有可能获得CPU。

##### 优先数调度算法
**算法**
 - 根据进程优先数，把CPU分配给最高的进程。
 - 进程优先数 = 静态优先数 +动态优先数

**静态优先数**
 - 进程创建时确定，在整个进程运行期间不再改变。

**动态优先数**
 - 动态优先数在进程运行期间可以改变。

##### LINUX进程的优先级
 - 每个进程都有一个优先级(亦称“nice 值”)，$Priorty = Priority - nice$
 - nice范围：-20（最高）～ 19（最低)
    - 默认情况进程的优先级是 0 
    - 普通用户只能降低自己进程的优先级，并限于 0 到 19 之间。
    - Root用户可以将任何进程的优先级设定为任何值

##### 循环轮转调度法（ROUND-ROBIN）
把所有就绪进程按先进先出的原则排成队列。新来进程加到队列末尾。

进程以时间片q为单位轮流使用CPU。刚刚运行了一个时间片的进程排到队列末尾，等候下一轮调度。

队列逻辑上是环形的。

#### Linux进程调度
1）基于优先级调度，选择优先级最高的进程运行。

2）既支持普通的分时进程，也支持实时进程；

3）让实时进程优先于普通进程；

4）保证普通进程公平使用CPU时间。


##### 优先级
**静态优先级**
 - 进程创建时指定或由用户修改。
     - sys_setpriority( )改变静态优先级
 - 表示该进程被允许运行的时间长短。
  
**动态优先级**
 - 在进程运行期间可以按调度策略改变。
 - 非实时进程采用动态优先级，由调度程序计算。
 - 只要进程占用CPU，优先级就随时间流失而不断减小。
 - task_struct的counter成员表示动态优先级。

#### 信号机制

C处理Signal

```c
signal(SIGNAL_TYPE,FUNC_PTR);

```