## 操作系统原理12


### 内存管理


#### 存储器功能需求
 - 容量足够大
 - 速度足够快
 - 信息永久保存
 - 多道程序并行

#### 存储管理的功能
1）地址映射
2）虚拟存储
3）内存分配
4）存储保护

##### 地址映射
 - 把程序中的地址（虚拟地址,虚地址,逻辑地址）变换成真实的内存地址（实地址,物理地址）的过程。
 - 地址重定位，地址重映射
 - 源程序－逻辑地址－物理地址

##### 方式
 - 固定地址映射
 - 静态地址映射
 - 动态地址映射

###### 固定地址映射

**定义**

***编程或编译时*** 确定逻辑地址和物理地址映射关系。

**特点**

 - 程序加载时必须放在指定的内存区域。

 - 容易产生地址冲突，运行失败。

###### 静态地址映射 

**定义**

程序 ***装入时*** 由操作系统完成逻辑地址到物理地址的映射。

**映射**
 - 逻辑地址：VA (Virtual Addr. Register)
 - 装入基址：BA (Base Addr. Register)
 - 物理地址：MA (Memory Addr. Register)
 - $MA = BA + VA$

VA为程序逻辑地址，**0x00000000** 开始线性递增

**特点**
 - 程序运行之前确定映射关系
 - 程序装入后不能移动
     - 如果移动必须放回原来位置
 - 程序占用连续的内存空间

###### 动态地址映射

**定义**
 - 在程序执行过程中把逻辑地址转换为物理地址。
     - 例如：MOV AX,  [500] ；访问500单元时执行地址转换

在执行时进行内存映射，动态进行。

**映射过程**

逻辑地址：VA(Virtual Addr. Register )
装入基址：BA(Base Addr. Register)
物理地址：MA(Memory Addr. Register)
MA = BA + VA


**注意：** 如果程序有移动，BA可能会有改变，自动计算新的MA。

**特点**

 - 程序占用的内存空间可动态变化
     - 要求及时更新基址BA
  
 - 程序不要求占用连续的内存空间
     - 每段放置基址BA系统应该知道

 - 便于多个进程共享代码
     - 共享代码作为独立的一段存放

**缺点**
  - 硬件支持（MMU：内存管理单元）
  - 软件复杂

##### 虚拟储存

**解决的问题**

1）程序过大或过多时，内存不够，不能运行；

2）多个程序并发时地址冲突，不能运行；


**方案**

 - 借助辅存在逻辑上扩充内存，解决内存不足
  
 - 把进程当前正在运行的部分装入内存（迁入），把当前不运行的部分暂时存放在辅存上（迁出），尽量腾出足够的内存供进程正常运行。
     - 辅存存放的部分当需要运行时才临时按需调入内存。
     - 进程不运行的部分往往占大部分,尤其是大进程。



###### 程序局部性原理
**时间局部性**

一条指令或数据，会在较短时间内被重复访问

例如：循环语句

**空间局部性**

任一内存单元及其邻近单元会在短时间内被集中访问

短时间内，CPU对内存的访问往往集中在一个较小区域内

例如：表，数组的操作

**结论：**
程序在一个 ***有限的时间段*** 内访问的代码和数据往往集中在 ***有限的地址范围内***。因此，一般情况下，把程序的一部分装入内存在 ***较大概率*** 上足够让其运行。

###### 实现虚拟存储的前提
足够的辅存

适当容量的内存

地址变换机构

###### 虚拟存储的应用
页式虚拟存储

段式虚拟存储

##### 物理内存管理

###### 固定分区

**定义**

把内存固定地划分为若干个大小不等的分区供各个程序使用。每个分区的大小和位置都固定，系统运行期间不再重新划分。

**分区表**

记录分区的位置、大小和使用标志

$e.g$

![分区表_example](https://wx1.sinaimg.cn/mw690/a954b2a4ly1g25fvhyhlrj21860u0x1l.jpg))

###### 动态分区

**定义**    

在程序 ***装入时*** 创建分区，使分区的大小刚好与程序的大小相等。

**特点**

分区动态建立

**例子**

![动态分区_1](https://wx4.sinaimg.cn/mw690/a954b2a4ly1g25fz9qdhoj21as0r6aor.jpg)

![动态分区_2](https://wx3.sinaimg.cn/mw690/a954b2a4ly1g25fz9c2jlj21920s2apb.jpg)

###### 分区的分配

**功能**

 - 在所有空闲区中寻找一个空闲区，分配给用户使用。

 - 基本要求：空闲区的大小应满足用户要求。

**空闲区表**：描述内存空闲区的位置和大小的数据结构


**过程**(假定用户要求的空间大小为SIZE)

（1）从空闲区表的第1个区开始，寻找 ≥SIZE 的空闲区

（2）找到后从分区中分割出大小为SIZE的部分给用户使用。

（3）分割后的剩余部分作为空闲区仍然登记在空闲区表中。

注意：分割空闲区时一般从 **底部** 分割。

**功能/定义**

选择1个空闲分区。从排好序的空闲区表中选择**第1个满足要求**的分区，分割给用户使用。

**空闲区表的排序原则**

按空闲区位置（首址）递增排序
 - 首次适应算法


按空闲区位置（首址）递减排序
 - …


按空闲区大小的递增排序
 - 最佳适应算法（**最小优先队列**）

按空闲区大小的递减排序
 - 最坏适应算法（**最大优先队列**）

###### 分区的回收

**功能**
回收程序结束后所释放的分区（释放区），将其适当处理后登记到空闲区表中，以便再分配。
要考虑释放区与现有空闲区是否相邻？

**回收算法**

若释放区与空闲区**不相邻**，则把释放区**直接插入**空闲区表。

若释放区与空闲区**相邻**，则把释放区和空闲区**合并**后作为新的更大的空闲区插入空闲区表。

###### 碎片问题
//TODO

###### 覆盖

**目的**

在较小的内存空间中运行较大的程序

**内存分区**

常驻区：被某段单独且固定地占用的区域，可划分多个
覆盖区： 能被多段 **共用（覆盖）** 的区域， 可划分多个

**工作原理**
 - 程序分成若干代码段或数据段
 - 将程序**常用的段**装入常驻区；（核心段）
 - **正运行的的段**处于覆盖区；
 - 将**目前不用的段**放在硬盘中(覆盖文件)；
 - **要用的段**从硬盘装入覆盖区（覆盖旧内容）；
     - 意义：减少程序对内存需求

**覆盖的缺点**

编程复杂：程序员划分程序模块并确定覆盖关系。
程序执行时间长：从外存装入内存耗时


###### 对换技术——Swapping

**原理**

内存不够时把进程写到磁盘（**换出/Swap Out** ）。

当进程要运行时重新写回内存（**换入/Swap In**）。

**对换技术的缺点**
 - 换入和换出增加CPU开销；
 - 对换单位太大（整个进程）：页/段。

**需要考虑的问题**
 - 程序换入时的地址重定位
 - 减少对换传送的信息量
 - 外存对换空间的管理方法

**采用交换技术的OS**
 - UNIX
-  Linux
-  Windows

#### 虚拟内存管理

**虚拟内存是 *面向用户* 的虚拟封闭存储空间。**
 - 线性地址空间。
 - 容量4G = $2^{32}$ Byte (32 bits OS)
 - 封闭空间（进程空间）
 - 和物理地址分离（地址无冲突）
 - 程序员编程时使用线性虚拟地址


##### 页式虚拟存储管理

把进程空间（虚拟）和内存空间都划分成等大小的小片
 - 小片的典型大小：1K，2K或4K…
 - 进程的小片——页（虚拟页或页面）
 - 内存的小片——页框（物理页）

![页与页框](https://wx3.sinaimg.cn/mw690/a954b2a4ly1g27q8ift7uj20ys0p87cw.jpg)

**进程装入和使用内存的原则**
 - 内存以页框为单位分配使用。
 - 进程以页为单位装入内存
     - 只把程序部分页装入内存便可运行。
     - 页在内存中占用的页框不必相邻。
     - 需要新页时，按需从硬盘调入内存。
     - 不再运行的页及时删除，腾出空间

![内存装入](https://wx2.sinaimg.cn/mw690/a954b2a4ly1g27qbl6yqoj20uw0rewkn.jpg)

**虚拟地址VA 分成页号P和页内偏移W**
 - 页号（P）
     - 所处页编号 = VA / 页大小
 - 页内偏移(W)
     - 所处页内的偏移 =  VA % 页大小

 - 例子
VA = 2500;  页面大小1K(1024)
 P  = 2500  /  1024 = 2 
 W = 2500 % 1024 = 452

方法2:
![](https://wx1.sinaimg.cn/mw1024/a954b2a4gy1g27qnyoijbj21620ow7av.jpg)

###### 地址映射

**页面映射表**

记录页与页框之间的对应关系。也叫页表。

 - 页号：登记程序地址的页号。
 - 页框号：登记页所在的物理页号。
 - 页面其他特性：登记含存取权限在内的其他特性。

###### 快表机制（Cache）

**快表的概念**

 - 页表放在内存中：慢表
 - 页表放在Cache中：快表

容量小,访问快，成本高。

**快表的特点**

 - 快表是慢表的部分内容的复制。
 - 地址映射时优先访问快表
    - 若在快表中找到所需数据，则称为“命中”
    - 没有命中时，需要访问慢表，同时更新快表

合理的页面调度策略能使快表具有较高命中率

***快表*** 只需访问内存**一次**

***慢表*** 访问内存**两次**

##### 页面的共享

**E.g：**
代码共享的例子——文本编辑器占用多少内存
 - 文本编辑器： **150KB代码段**和**50KB数据段**
 - 有10进程并发执行该文本编辑器。
 - 占用内存 = 10 x（150＋50）KB ＝ 2M

如果采用代码段共享，代码段在内存只有一份真实存储
 - 占用内存 = 150 + 10 x 50 = 650KB

**页面共享？**
 - 根据页式地址转换过程：如果在不同进程的页表中填上相同的页框号，就能访问相同的内存空间，从而实现页面共享。
 - **共享页面**在内存**只有一份真实存储**，节省内存。

##### 页表的建立

**页表的建立**
 - 操作系统为每个进程建立一个页表
     - 页表长度和首址存放在进程控制块中。
 - 当前运行进程的页表驻留在内存
     - 页表长度和首址由页表长度寄存器和页表首址寄存器指示。

**页表的形式**
 - CACHE
    - 访问速度快，成本较高。　
 - 内存
    - 成本较低，访问速度慢。

##### 页表扩充——带中断位的页表

扩充有中断位I和辅存地址的页表


![](https://wx3.sinaimg.cn/mw1024/a954b2a4ly1g27sapmhfaj20tc0asmyp.jpg)


中断位I ——标识该页是否在内存?
 - 若I =１，不在内存
 - 若I =０，在内存

辅存地址——该页在辅存上的位置

##### 缺页中断

**定义**
 - 在地址映射过程中，当所要访问的目的页不在内存时，则系统产生异常中断——缺页中断。
  
**缺页中断处理程序**
  - 中断处理程序把**所缺的页从页表指出的辅存地址调入内存的某个页框中**，并更新页表中该页对应的**页框号**以及**修改中断位I为0**。

##### 访存指令的执行过程（含缺页中断处理）

![](https://wx3.sinaimg.cn/mw1024/a954b2a4ly1g27sh6wfqwj218e0tgh1e.jpg)

#####页式系统的实时性
**缺页中断 vs 普通中断**

相同点
处理过程：保护现场、中断处理、恢复现场

不同点
 - 响应时机
   - 普通中断在指令完成后响应
   - 缺页中断在指令执行过程中发生
 - 发生频率
   - 一条指令执行时可能产生多个缺页中断

